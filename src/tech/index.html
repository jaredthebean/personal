<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="A technical blog.">
  <link
    href="https://fonts.googleapis.com/css2?family=Pinyon+Script&family=Martian+Mono&family=Newsreader&family=Saira&family=Fira+Code&display=swap"
    rel="stylesheet">
  <title>Jared's Name</title>
  <link rel="stylesheet" href="/base.css">
  <link rel="stylesheet" href="page.css">
</head>

<body>
  <header>
    <nav>
      <ul>
        <li><a href="/">Name</a></li>
        <li><a href="/rÃ©sumÃ©/">RÃ©sumÃ©</a></li>
        <li><a href="/tech/">Tech</a></li>
      </ul>
    </nav>
  </header>
  <main>
    <div class="reading">
      <h1>It's a <code>-&gt;<wbr>Technical<wbr>&lt;-</code> Blog</h1>
      <section class="intro">
        <h2>Intro</h2>
        <p>
          This is where I do little write-ups about technical things I encounter and find interesting.
          I'll try to make them more generally accessible than the notes I write to my future selves.
        </p>
      </section>
      <section class="articles">
        <h2>Article(s)</h2>
        <section class="intro">
          <h3>Dev Containers</h3>
          <p>
            So I like to use dev containers<a href="https://containers.dev/" class="cite" target="_blank"></a>,
            as part of my developer workflow. Specifically I like to keep whatever funniness 
            happens in a coding project (setup, experiments, etc.) contained <em>to</em> that
            project and not let it spill out into the rest of my system.  As I don't do
            kernel-level things much Docker provides all the isolation I need.
          </p>
          <p>
            As a side benefit it also keeps me honest in terms of being able to set up (and
            therefore also nuke) a dev environment quickly.
          <aside>
            <button aria-label="Toggle Aside"></button>
            <div class="expandable-wrapper">
              <div class="expandable-content">
                <p>
                  I guess the industry term for this is <q>pets vs cattle</q>
                  <a href="https://cloudscaling.com/blog/cloud-computing/the-history-of-pets-vs-cattle/" class="cite" target="_blank"></a>.
                  I always found this analogy slightly discomforting as converting what was once 
                  classified as pets to something classified as cattle in real life feels like a
                  definite moral step backwards.  It always makes me start to imagine myself
                  starting to treate my dog or cat like cattle in a herd, and following the spirit
                  of the analogy I would say I would need to be treating them like a particularly
                  cold-hearted farmer would. Though I suppose I come from a dairy farming family
                  and not a beef cattle farming one so we may grow a little more attached to our
                  cattle?
                </p>
                <p>
                  Needless to say that line of thought is never pleasent to be reminded ofâ€¦ sorry.
                </p>
              </div>
            </div>
          </aside>
            Mostly that boils down to two things:
          <ol>
            <li>
              <p>
              Keeping my dotfiles well organized. Meaning they can configure 
              almost-certainly-already-present base utilities found on almost every Linux machine
              (<code>vi</code>, <code>sh</code>, <code>grep</code>, <code>less</code>, etc.),
              but they can also pull down "nice-to-have" dev environment dependencies 
              (<code>vim</code>, <code>zsh</code>, <code>bat</code>, other new-age, Rust CLI
              utitility replacements I have become so fond of) as needed.
              AKA I've gotten soft and if I'm going to be working in an environment for a while
              I want to be more <em>comfortable</em> than having a set of tools that will work,
              I want the tools that I like - with pretty colors and everything. So sue me. 
              </p>
            </li>
            <li>
              <p>
                Knowing how to connect two environments together securely &amp; comfortably.
                Accessing a shell in one environment from my laptop, getting a GUI to display from
                one environment in another, being able to access a 'locally' hosted web service in
                one environment from another, sharing files - all of these would fall under this
                banner.
              </p>
            </li>
          </ol>
          <p>
            Lately, I've realized that while I've gotten pretty comfortable with Docker in terms
            of a number of use cases I do regularly, I didn't really understand its internals or how
            it did what it did. I was limited in my understanding because I didn't know what
            lower-level things it was built on and what sort of inherent limitations they would
            introduce to its functions.  One concrete thing that brought this to light was needing
            to connect an X application in a dev container to the X server on the host (aka my
            laptop) which controlled its display/screen/etc.
          </p>
          <aside>
            <button aria-label="Toggle Aside"></button>
            <div class="expandable-wrapper">
              <div class="expandable-content">
                <p>
                X here refers to the X Windowing System
                <a href="https://en.wikipedia.org/wiki/X_Window_System" class="cite" target="_blank"></a>
                <a href="https://www.x.org/wiki/guide/concepts/" class="cite" target="_blank"></a>
                and not the site formerly-known-as Twitter. It is a windowing system, originally
                from the late 1980's that has ruled the Linux roost for some time (though now there
                is a new one called Wayland
                <a href="https://wayland.freedesktop.org/" class="cite" target="_blank"></a>
                 - though like with any big change to an old and
                fundamental piece of the open source world there is a bit of drama around which to
                use currently.) 
                </p>
                <p>
                  Thought I should include this aside as I got a few questions about what this all
                  had to do with the x.com ðŸ« .
                </p>
              </div>
            </div>
          </aside>
          <p>
            This brought up a number of questions in my mind.
          </p>
          <ul class="questions">
            <li>
              <p class="question">Should this be a port forwarding thing? Maybe SSH?</p>
              <p class="reasoning">
                A couple of the dev-container utilities I had used
                (VSCode extension & Devpods) seemed to use those as their go-to solutions for
                connecting host to container.
              </p>
            </li>
            <li>
              <p class="question">What about mounts?</p>
              <p class="reasoning">
                I mean the folder mount of a project's code to the "workspace" in a dev container is 
                <em>the</em> fundamental connection between my host and dev container. Outside of
                that, named UNIX domain sockets were how SSH agent forwarding worked as far as I
                could tell (so I didn't have to go in and out of my container to do authenticated things like 
                connect to AWS or sign my commits.)
              </p>
            </li>
            <li>
              <p class="question">Does this have something to do with <code>cgroups</code>?</p>
              <p class="reasoning">I keep seeing that term crop up, but I have no
                idea what it is? How does Docker even work? What are its component systems and how do I
                trade-off between them and/or use them "correctly" and not just abuse them in 
                the depths of my ignorance?
              </p>
            </li>
          </ul>
        </section>
        <section class="history">
          <h3>History & Context</h3>
          <p>
            Well that last question exposed the underlying problem of me not understanding how
            Docker or containers worked or what they were built on. As you can see that kicked
            off a whole stream of questions all having to do with <q>How does any of this work?
            </q>, so I decided to embark on a learning excursion. 
          </p>
          <p>
            Turns out, as far as I could tell, Docker is kinda a nice convenience layer on top
            of a bunch on different Linux kernel functionalities that ties them all together to give
            you a mostly isolated environment. In this respect, the most useful learning resource
            for me wasn't Docker (or container) specific, but was just a book on how Linux works.
          </p>
          <p>
            I mean I've used Linux for nearly two decades now, but looking back on it everything I knew
            was hobbled together from disparate
            <code>man</code> pages and noticing things changing as I
            updated my distro.
            <q>Oh look,
              <code>/etc</code> config files now have
              <code>*.d/</code> folders
              that the main file tells me to use. Guess I'll do that.
            </q>
          </p>
          <aside>
            <button aria-label="Toggle Aside"></button>
            <div class="expandable-wrapper">
              <div class="expandable-content">
                <p>
                  I dual-booted Linux & Windows on my first laptop: a Dell with an Nvidia GPU.
                  Everytime I would update the kernel I would lose access to my GUI and GNOME
                  <a href="https://en.wikipedia.org/wiki/GNOME" class="cite" target="_blank"></a>
                  <a href="https://www.gnome.org/" class="cite" target="_blank"></a>
                  and only have a lonely TTY. My Wi-Fi was gone too as
                  <code>wpa-supplicant</code>
                  <a href="https://wiki.archlinux.org/title/Wpa_supplicant" class="cite" target="_blank"></a>
                  <a href="https://man.cx/wpa_supplicant(8)" class="cite" target="_blank"></a>
                  seemed to be tied to the GNOME display manager (as an applet? at least I remember
                  it didn't start with its normal configuration outside of <code>gdm</code>
                  <a href="https://man.cx/gdm" class="cite" target="_blank"></a>.)
                </p>
                <p>
                  No Wi-Fi meant no searching the forums for how to fix things and even if I did
                  regain Wi-Fi I couldn't start a GUI browser. This is when I learned how to write
                  configuration for <code>wpa-supplicant</code> by hand (after using a university
                  computer to search the forums) - which was no fun - and also how to navigate the
                  TUI, ASCII-art-based, web browser <a href="https://lynx.browser.org/">Lynx</a> -
                  which was a <em>lot</em> of fun.
                </p>
                <p>
                  I eventually wrote a script for the unfun part. (As well as messing with X and
                  kernel modules that normally re-enabled the GUI.) But still got to dive into
                  <a href="https://lynx.browser.org/">Lynx</a> a good bit as my Nvidia graphics
                  fixes needed tweaking fairly frequently as the drivers were apparently
                  undergoing big changes.
                </p>
              </div>
            </div>
          </aside>
          <p>
            I knew specific parts of Linux, and more often than not, how to do specific things
            <em>with</em> those specific parts, but I never really got a <q>this is how it is all
            connected</q> design overview or the rational behind how things progressed and changed.
            This style of learning also meant that there just were parts of Linux that I
            straight-up didn't encounter and knew next to nothing about.
          </p>
        </section>
        <section class="book">
          <h3>The Good Book</h3>
          <p>
            What solved this for me was the excellent book
            <a href="https://nostarch.com/howlinuxworks3">"How Linux Works, 3rd Edition" by Brian Ward</a>
            and, hey, it finally answered what
            <code>cgroups</code>
            <a href="https://docs.kernel.org/admin-guide/cgroup-v2.html" class="cite" target="_blank"></a>
            were.
          </p>
          <aside>
            <button aria-label="Toggle Aside"></button>
            <div class="expandable-wrapper">
              <div class="expandable-content">
                <p>
                  <code>cgroups</code>, aka control groups, are mostly about controlling how much
                  of a system's resources a set of processes use. It is interacted with mostly via
                  the filesystem (like good ol' <code>/proc</code>.) Mine is rooted at
                  <code>/sys/fs/cgroups</code> but a quick invocation of the <code>mount</code>
                  should list where the <code>cgroup2</code> filesystem type is mounted. For
                  containers you can see how it can provide protection against things like
                  fork-bombing even outside of multi-tenant environments.
                </p>
              </div>
            </div>
          </aside>
        </section>
        <section class="answers">
          <h3>Answers</h3>
          <p>
            Now that I knew that Docker is a convenience layer that bundles together a number of
            built-in Linux kernel features to make a cohesive API/environment that I can think of
            as a "container", I was able to start to answer some of the questions from above.
          </p>
          <ul class="answers">
            <li>
              <p class="question">Should this be a port forwarding or SSH thing?</p>
              <div class="answer">
                <p>
                  It could be. If I was going to possibly want dev containers on other machines
                  connected through a network than this would make that easier. For SSH tunnelling
                  I need an SSH server <em>in</em> my container which is a bit annoying to have
                  to add to <em>every</em> dev container I use, so I would prefer it if I didn't
                  need one.
                </p>
                <p>
                  Since X tends to use UNIX domain sockets locally and I was planning to do my
                  development on my local machine, SSH seemed like too much and I might as well
                  use the existing UNIX domain socket and not worry about port forwarding. Also
                  opening up an X network port seemed iffy since it has all the naÃ¯ve trusting
                  tendencies of software developed in the 1980's. I mean that's why everybody always
                  tunnels it with SSH (well that and because SSH has built-in, specialized,
                  packet-sniffing support for X protocol tunnelling, sheesh - no wonder that's what
                  we always use.)
                </p>
              </div>
            </li>
            <li>
              <p class="question">Mounts?</p>
              <div class="answer">
                <p>
                  Yeah, this is what I was looking for. X uses named UNIX domain sockets that are
                  accessible via a filesystem path, I'm using this for local development, ... its all coming together.
                </p>
                <aside>
                  <button aria-label="Toggle Aside"></button>
                  <div class="expandable-wrapper">
                    <div class="expandable-content">
                      <p>
                        As it turns out X hardcodes where it puts its UNIX domain sockets
                        <a href="https://github.com/Martin1994/xcb-libxcb/blob/be1745c8eb00defcb31d336ccc142de056e92bd8/src/xcb_util.c#L232"
                          class="cite" target="_blank"></a>
                        so I don't really need to do much fancy footwork (enforce a configuration
                        or read an environment variable or anything except know that <em>this</em>
                        path is the right and true directory for X server UNIX domain sockets.)
                      </p>
                      <p>
                        This does make mounting it in Docker a <em>little</em> annoying as other
                        things like to mount a RAM <code>tmpfs</code> filesystem to <code>/tmp</code>. In
                        particular the Docker in Docker feature for dev containers likes to do so in
                        its container startup script
                        <a href="https://github.com/devcontainers/features/blob/e3e3ed76c4778e1ec51cae7c11e74565d0052a7f/src/docker-in-docker/install.sh#L524-L526" class="cite" target="_blank"></a>.
                        If I mount a <em>sub</em>folder (or file) of <code>/tmp</code> then
                        it'll get kludged by this script. As a workaround I mount <code>/tmp</code>
                        as a RAM filesystem ahead of time because the Docker in Docker container 
                        script is kind enough to check that <code>/tmp</code> itself isn't
                        already a mount that it shouldn't kludge.
                      </p>
                    </div>
                  </div>
                </aside>
              </div>
            </li>
            <li>
              <p class="question">
                Control Groups?
              </p>
              <div class="answer">
                <p>
                  As noted above, no this has nothing to do with what I was attempting.
                  It is just the kernel feature that allows Docker to do host resource
                  limiting.
                </p>
              </div>
            </li>
          </ul>
        </section>
        <section class="future">
          <h3>Onwards</h3>
          <p>
            Well I found my solution and I got to learn more about how Docker &amp; containers in
            general work so that's cool.
          </p>
          <p>
            Now what to learn about next? Maybe one of the kernel features that are bundled up by
            Docker to make containers:
          </p>
          <ul>
            <li>
              <p>Capabilites</p>
            </li>
            <li>
              <p>Mounts</p>
            </li>
            <li>
              <p>Control Groups</p>
            </li>
            <li>
              <p>Namespaces</p>
            </li>
            <li class="chosen">
              <p>Networking</p>
            </li>
          </ul>
          <p>
            I think I want to dig a little more into the networking bit next.
            I'd like to understand <code>iptables</code> (or its successor if that has hit prime
            time and taken over the spot light now?), maybe some traffic control? Basically
            I want to understand what all I can control using kernel networking utilities
            as they <em>seem</em> pretty powerful and I want that tool in my toolbelt.
          </p>
          <p>
            Well that's that for now. TTYL.
          </p>
        </section>
      </section>
    </div>
  </main>
  <script>
    for (const b of document.querySelectorAll("aside > button:first-child")) {
      b.addEventListener("click", evt => evt.target.parentElement.classList.toggle("expand"));
    }
    for (const b of document.querySelectorAll("aside")) {
      b.addEventListener(
        "click", evt => 
        {
          if (!evt.target.classList.contains("expand")) {
            evt.target.classList.toggle("expand")
          }
        }
      );
    }
    let i = 1;
    for (const a of document.querySelectorAll("a.cite")) {
      a.innerHTML=i++;
    }
  </script>
</body>

</html>